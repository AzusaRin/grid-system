我在这里使用flex布局实现了一个栅格系统。
首先创造了一个大的父元素container，将他用@media（min-width）设置成为根据浏览器页面宽度自动更新三段的宽度。
接着我创造了两个直系子元素，分别是装着1,2,3,4的row和装着aside，main的row。
设置这个row为display：flex；他的这些直系子元素就变成了flex items。
设置flex-flow: row wrap;保证他们能够自动折行。
在这些直系子元素中根据自己的需要，设置Bootstrap格式的占列宽度。
数字 (1-12) 代表任何 div 总宽度的一部分。所有 div 分为 12 列。
而这些英文字母分别代表：
xs =超小屏幕（手机）
sm =小屏幕（平板电脑）
md =中等屏幕（某些桌面）
lg =大屏幕（剩余桌面）
我们这时候使用@media（min-width）来设置每一份占用div的多少。我这里简单的把div分成12块，也就是每一个数字之间差距是1/12也就是width的8.3333333%。以此类推。
使用flex-basis来决定每一个元素所占的宽度。
例如<div class="col-xs-12 col-lg-6">1</div>
是指这个div占据父盒子的宽度有两个数值，一种是在超小屏幕手机的情况下，按照col-xs-12的标准，占据100%的宽度。一种是在大屏幕的情况下，按照col-lg-6的标准，占据50%的宽度。
而怎么样算是xs，怎么样算是md，之类，是我自己决定的。
我在这里决定当width<768px的时候是xs，width>=768px && <992px的时候是sm，width>=992px && <1200px的时候是md，width>=1200的时候是lg。
由于我们的main和aside未设置在md标准以下的宽度，flex items的宽度会收缩。也就是说当width<992px的时候，aside和main的宽度只由内容撑开。
那么我们必须要设置一个初始宽度，也就是在一开始设置二者的width:100%;
这样我们就实现了一个栅格系统。